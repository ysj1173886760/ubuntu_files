### RAII 拓展

今天的内容主要取自《Effective C++》

之前有一节我有讲到有关RAII的用法

今天重新回去读了一下effective c++才发现之前自己有一部分理解是错的

这里进行一个纠正，并进行一点对RAII的补充

以对象管理资源的观念被称为RAII，因为我们总是在获得一笔资源后于同一个语句内以他初始化某个资源管理对象

所以对RAII的理解指的是资源管理对象的初始化是在资源获取的同时进行的

所以也可以叫这种资源管理对象RAII对象

智能指针就是一种RAII对象，C++中没有为动态分配数组设计的类似智能指针的RAII对象，所以请尽量使用vector或string来替代

如果打算自己实现资源管理类，请考虑以下几点

首先对于资源管理类的copy行为，我们可以禁止复制

因为很少能够合理拥有同步化基础器物的副本，同步化基础器物指的是用于多线程同步的一些器件，比如互斥锁，信号量

这些东西被复制是不合理的，想象一下你用一个LockManager管理一个临界区，然后复制这个Manager，里面的锁是锁住的还是没锁住的呢?

还有一种做法是我们可以用引用计数，我们可以保有资源直到它的最后一个使用者被销毁

这样他们管理的资源是不变的，我们只需要维护一个计数器来记录管理这个资源的对象的数量即可

或者我们可以选择复制底层资源，以及转移资源的控制权，就像深拷贝和auto_ptr那样

最后，我们需要在资源管理类中提供对原始资源的访问，就像是智能指针中的get一样

虽然智能指针重载了`-> *`运算符，但是仍然需要提供一个访问底层资源的接口，因为很多API都需要直接访问原始资源

可以显示的访问原始资源，或者重载类型转换运算符，隐式得到原始资源，但是显示的更加安全

[同步化基础器件](https://stackoverflow.com/questions/8017507/definition-of-synchronization-primitive)