

对之前做的codeforces的一些题的总结

题目普遍算法难度不是很高，但是思维难度对我来说就快到头了

希望接下来一年的时间能打上1900分

之前打的比赛也不算少，一次可能做不完，之后会保证每次比赛后都及时总结的

代码就不弄太多了，尽量总结思维方法，如果有重要的实现技巧也会粘上去的



### Codeforces round 670

A. Subset Mex

给一堆数，叫你分成两个集合A, B ，Mex(A)表示的是集合A中最小的非负整数，你要最大化Mex(A) + Mex(B)

由于对于一个数来说，如果他是唯一的，那么你丢给A还是丢给B结果是一样的，如果不是唯一的就各分一个，所以把这些数从小到大的丢给A和B即可

B. Maximum product

给一堆数，求出最大的五个数相乘的乘积

先说一下我的做法吧，设$Max_{ij}$ 表示的是从1到i，最大的j个数的乘积，同理$Min_{ij}$ 就是最小的j个数的乘积，对于每个数来说，最大的j个数的乘积可能由最大的j-1个数乘上当前的数得来，也可能是由最小的j-1个数乘当前的数得来，最小的j个数的乘积的转移也同样，这个算法同样适合求最大K个数的乘积

```c++
maxx[j] = max(maxx[j], max(maxx[j - 1] * x, minn[j - 1] * x));
minn[j] = min(minn[j], min(minn[j - 1] * x, maxx[j - 1] * x));
```

题解的思路就是先排序，如果最大的5个数的乘积是整数，那就是答案，否则答案就一定是最大的四个数乘剩下n-5个数中其中一个得来的

C.  Link Cut Centroids

给一颗树，让你删一条边再加上一条边，使得树的重心变成唯一的

先说重心，如果你把一个节点删去，剩下的所有部分中最大的节点数最小时，那么删去的节点就是重心

重心有个很特殊的性质，就是如果存在两个重心，那么这两个重心一定是相邻的

重心可以用一遍dfs以O(n)的时间求下来，如果重心有一个，那么不需要对这个树进行改动

如果重心有两个，删去其中一个重心的一条枝干并把其连接到另一个重心上，即让另一个重心变得重一点即可

D. Three Sequences

给一个序列a，叫你分成两个序列b和c，满足$a_i = b_i + c_i$ 其中b是不降序列，c是不增序列，现在要求最小化序列b,c中的最大值，还附加若干次区间修改，求每次修改后的答案

由于b,c序列的特殊性质，我们所需要最小化的其实是$(c_1, b_n)$ 有一个比较好的构造方法（*虽然我也没想出来*）是如果$a_i < a_{i-1}$ 那么 $c_i = c_{i-1}$改变

否则就改变c，现在令K为$\sum_{i = 2}^nmax(0, a_i - a_{i - 1})$ 即所有b的增量，那么假设$c_1$为x，那么$b_1$就是$a_1 - x$，那么$b_n = a_1 - x + K$ 那么就是最小化$max(x, a_1 - x + K)$ 那么x就应该为$(a_1 + K) / 2$ 

对于q次修改，使用差分数组维护K的值，最后O(1)算出答案即可



### Educational Codefoces Round 95

A. Buying Torches

一开始有1个木棍，1个木棍可以换x个木棍，y个木棍换一个煤炭，1个木棍和1个煤炭可以做一个火把，问最少换多少次可以做k个火把

正常的算一下就可以得出答案为$\lceil$$\frac{ky+k-1}{x-1}$$\rceil$ 这里有一个实现上的小技巧 $\lceil\frac{a}{b}\rceil = \lfloor\frac{a + b - 1}{b}\rfloor$ 注意是整数

B. Negative Prefixes

给一个数组，一开始有一些数是固定的，你要重排那些没固定的数，K是使得前缀和小于0的最大的数，你要最小化K

最直观的想法就是如果总和是负数的话，那么怎么改变都是没用的，否则就尽量把正数堆到前面，这样可以让后面的出现尽可能少的负数

有一个实现细节就是

```c++
sort(a.rbegin(), a.rend());
```

代表的是把a从大到小排序

C. Mortal Kombat Tower

给一个01序列，A和B分别取数，A先开始，每次只能取1或者2个，最小化A取到的1的个数

可以使用$dp[i][who]$作为状态进行转移

另一种思路是如果$a_1 = 1$那么A必须取这个1，考虑一段连续的1，我们可以构造一种方案使得第一个1总是可以先被B取到，而对于每一段连续的0，都可以让A先取到，对于111，则B取前两个，A取最后一个，对于1111，则B取前两个和最后一个，A取第三个，对于000，A取第一个和第三个，B取第二个，那么我们总可以让B先取连续的1，A先取连续的0，最终计算答案即可。

D. Trash Problem

有n堆垃圾，每个垃圾有一个坐标，现在要把这n个垃圾合并成两堆，问最小的移动步数，同时有若干个添加垃圾和删除垃圾的操作，算出每次操作后的最小移动步数

用一个set和一个map，分别维护所有垃圾的坐标，以及相邻垃圾的间隔，那么答案就是最大坐标减去最小坐标再减去最大间隔

对于每次插入和删除操作，都更新垃圾的坐标以及相邻的间隔，细节较多

### Codeforces Round 671

A. Digit Game

给一个正数序列，两个人标数，A只能标记奇数，B只能标记偶数，A先开始，最后剩下一个数的时候，如果剩下的是奇数，A赢，否则就是B赢，两个人都是最优策略，问谁赢

稍微想一下就可以得出，如果一共有奇数个数，那么最后剩下的数肯定是奇数位置的数，如果一共有偶数个数，那么最后剩下的就是偶数位置的数

两个人都是最优策略，那么倘若有奇数个数，B无论选什么都无所谓，因为最终的决定在奇数位置的数，所以倘若奇数位置的数有一个是奇数，A只要留下那个数不选，最后A就可以获胜，B也是同理。所以看起来是两个人在博弈，实际上是自己在和自己玩，因为两个人的决策不会冲突

B. Stairs

这个题描述有点复杂，可以的话还是去原网址看一下题吧 [B. Stairs](http://codeforces.com/contest/1419/problem/B)

不过题还是蛮简单的，每次边长都会变为原来的2倍，那么需要的方块数就是原来的四倍，同时前面方块需要的数量也翻倍，这个画个图就可以看出来

提前预处理出每种楼梯需要的方块数，然后贪心的选取即可，因为不会有比贪心更优的策略，所以我们再预处理出前缀和就可以很快解决问题。

C. Killjoy

由若干个账户，给你他们的分数，最开始有一个账户被感染了，每次你可以选择若干个账户参加比赛，他们的分数随意变化但是同一场比赛的人的总分不能变，当有人和被感染的账户分数相同时，那么他们就都被感染了，问最少需要多少次才能把所有人都感染

很显然，如果所有人的分数一开始都是相同的，那很显然就是0次就可以

如果剩下的人的平均分和最开始的感染账户的分数相同，那么我们只需要让剩下人参加一次比赛并均分他们的分数，即可让所有人都感染

如果剩下的人中，有一个人的分数和最开始感染账户的分数相同，那么这个人显然一开始就被感染了，然后我们让所有的人都参加比赛，其中令两个感染的其中一个的分数不变，其他所有未感染的人的分数等于这个感染账户的分数，那么剩下的分数让剩下的感染账户来补全，即我们只需要一次既可以让所有人都感染

否则，我们就可以最开始随便选定一个人，让他和感染账户的分数进行平分，那么两个人的分数就都相同，那么情况就转换为了上面那种情况，我们需要的操作次数就是两次

D1. Sage`s Birthday (easy version)

给一个序列，数字无重复，让你重排该序列，使得波谷数量最多，其中两端点不可能成为波谷

先排序确定大小关系，由于差值的大小是无意义的，所以我们不用关心具体放谁，只要关心放大还是放小就好，那么很显然，数组的前一半可以划分为小，后一半划分为大，我们每次从大数里去一个放进去，再从小数里去一个放进去，不断重复即可。

D2. Sage`s Birthday (hard version)

题意基本不变，但是给的序列其中的数字会出现重复

其实思路还是不变的，我们仍然可以按照相同的策略进行放置，放到新的数组里最后统计一下结果即可

这里要注意的是放的时候我们是两个有序的序列都从小开始放的，如果你按照最大最小的方案放置，那么到中间可能出现重复的元素就会影响答案

### Codeforces Round 672

[A. Cubes Sorting](http://codeforces.com/contest/1420/problem/A)

给一个序列，问是否存在$\frac{n*(n-1)}{2} - 1$次交换可以使其变为有序的

一个数组最多存在$\frac{n * (n - 1)}{2}$个逆序对，也就是说，排序的时候最多交换$\frac{n * (n - 1)}{2}$次

也就是说，只要数组存在一个非逆序对，我们就可以把其变成有序的，如果数组无非逆序对，也就是纯逆序，那我们就不能把他变成有序的

[B. Rock and Lever](http://codeforces.com/contest/1420/problem/B)

给一个序列，找出所有满足x and y >= x xor y的数量

找几个数把2进制写出来就可以发现 如果$log_2(x) == log_2(y)$那么他们就满足条件，所以我们直接用cmath中的log2函数计算就好

代码有一定参考价值

```c
for (int i = 1; i <= n; ++i) {
        int x = 0;
        scanf("%d", &x);
        int lg = log2(x);
        ans += sum[lg];
        sum[lg]++;
}
```

[C1. Pokémon Army (easy version)](http://codeforces.com/contest/1420/problem/C1)

题意有点懒得描述，点进去看看题吧

我们要累加波峰与波谷的差值，并使其最大化，所以我们肯定是尽可能的找高的波峰，尽可能的找低的波谷

那么贪心就出来了，对于一段连续下降的序列来说，我们取其最后一个值为波谷，而对于连续上升的序列来说，我们取其最后一个值为波峰

不断累加即可

[C2. Pokémon Army (hard version)](http://codeforces.com/contest/1420/problem/C2)

这个就是多了交换的操作，并求出每次交换后的答案

对于上一题来说，我们可以发现，我们加上了所有的波峰，并减去了所有的波谷

我们把第0 和 n+1的位置设置成负数，这样可以让第一个元素和最后一个元素不成为波谷

对于交换操作，可以发现，一个数是否造成贡献取决于他的前后两个数，同时他也会影响他的前后两个数，那么我们在修改的时候就要涉及到6个数的贡献的问题

先都删除，减去贡献后交换元素，再插入重新计算贡献即可

[D. Rescue Nibel!](http://codeforces.com/contest/1420/problem/D)

给若干个线段，选出k个线段使交集不为空，问有多少种选择方法

这个题思路很棒，对于由于点是离散的，对于每个点我们可以单独计算答案，最直观的想法就是设$p(x)$为穿过x点的线段的条数，那么答案就是${p(x) \choose x}$，但是很显然是不会的，因为有可能有多条线段同时穿过了多个点，那么我们就会计算重复。令$s(x)$表示以x为起点的线段的条数，那么${p(x) \choose x} - {p(x) - s(x) \choose x}$就代表的是选k条穿过x的线段，其中至少有一条是以x为起点的，那么对于所有的x，我们累加就可以得到答案，因为我们每次都至少有一条是以x为起点，那么对于不同的x来说方案总是不同的，所以这个答案是正确的

代码实现方面作者也做的很巧妙，他叫这个技巧为event

```c++
for (int i = 1; i <= n; i++) {
     	int l, r;
        scanf("%d %d", &l, &r);
        events[i] = l * 2;
        events[i + n] = r * 2 + 1;
    }
    sort(events + 1, events + 1 + 2 * n);
    int ans = 0;
    int cross = 0;
    for (int r = 1; r <= 2 * n;) {
        int l = r;
        while (events[r] == events[l] && r <= 2 * n)
            r++;
        int st = r - l;
        if (events[l] % 2 == 0) {
            ans += c(cross + st, k);
            ans %= mod;
            ans -= c(cross, k);
            ans = (ans + mod) % mod;
            cross += st;
        } else {
            cross -= st;
        }
    }
```

