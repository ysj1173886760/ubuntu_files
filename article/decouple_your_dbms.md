# Decouple Your DBMS

![20220507103647](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220507103647.png)

把上层做成无状态的，并发控制等信息下沉到存储层。schema，shard等元信息存在单独的metadata server中

关键是理清不同的DSL他们的执行流程

有关事务以及存储：存储引擎不决定存储格式，而是由并发控制策略决定。存储引擎只负责存储数据，以及读取数据，不关心数据的具体含义。一个实现的思路就是类似列族，把各种元信息都通过列族来存，从而把并发控制和存储隔离开。

有关读取的流程：
执行器发起读/写，事务管理器根据具体的并发控制类型来决策，比如OCC，我们就发起一次读写并存放到本地buffer，比如Lock-based，就尝试上锁，或者MVCC，则遍历每个版本，选择对应的数据。涉及到具体的数据读写的时候则是由存储引擎负责。比如我们可以只是返回一个未解释的字节串，然后通过schema来转化成一个tuple，再传回给上层事务

![20220509140549](https://picsheep.oss-cn-beijing.aliyuncs.com/pic/20220509140549.png)

如果下层存储引擎有schema的信息，我们就可以只是读取必要的数据。貌似没什么缺点？

核心就是把执行层，事务层和存储层分开。

执行层负责根据执行计划去计算，并向下层发起读写请求。

事务层根据读写请求执行对应的并发控制算法，比如2PL我们就先上锁，再读数据。比如MVCC我们就遍历版本链，选择可见的数据返回。

事务层发起的读写操作会转换成存储层的操作，比如对具体数据的读写（中间可能有一个间接层是通过元信息来把tuple转化成下层字节串的读写）