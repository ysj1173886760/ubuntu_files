### pop的返回类型

这里说的是C++标准库中的stack和queue容器的pop成员函数

我们在平常的使用过程中就可以知道，这两个容器（或者叫容器适配器）的pop函数的返回值都是void，但是为什么标准库要这么设计这个接口呢？

或者问，为什么返回值不设置成容器中元素的类型呢？

对于多线程的情况，如果我们想取出pop的元素，就需要执行 `stack.top` 和 `stack.pop` 两步

如果我们的pop可以直接返回对应的元素，就不用担心我们的操作会被其他的线程干扰，因为我们的操作具有原子性

举个例子，假设我们有两个线程，两个线程共用一个栈

```cpp
stack = {1, 2}  // 栈中两个元素 1为栈顶

func() {
    print stack.top()
    stack.pop()
}

CreateThread(func)
CreateThread(func)
```

对于这种情况，我们可能输出的结果就是 {1, 2} {1, 1}

因为我们可能有第一个线程先执行print，然后第二个线程执行print，两个都输出的是1，然后再都进行一次pop

但是如果我们的pop是返回元素

```cpp
func() {
    print stack.pop()
}
```

那么情况就是 {1, 2}

所以直接返回元素是更加友好的一种方式，但为什么C++没用呢？？

pop的接口是在C++98时决定的，那个时候还不存在移动构造的概念，所以如果我们想pop出一个值，就需要调用拷贝构造函数

当该元素的拷贝构造函数有可能发生异常时，我们构造新元素的过程失败，但是之前的元素已经（或者未被）弹出，无论哪一种情况都不是我们想要的

即拷贝构造函数出现异常时，之前的容器元素有可能已经被改变了，不满足异常安全

所以最终选择了不返回元素的版本

[参考](https://time.geekbang.org/column/article/173167)