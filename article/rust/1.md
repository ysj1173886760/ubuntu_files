### Daily Rust 有关所有权和生命周期的一些问题

首先看一段代码

```rust
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    id: usize,
    downstream: Option<Rc<Node>>,
}

impl Node {
    pub fn new(id: usize) -> Self {
        Self {
            id,
            downstream: None,
        }
    }

    pub fn update_downstream(&mut self, downstream: Rc<Node>) {
        self.downstream = Some(downstream);
    }

    pub fn get_downstream(&self) -> Option<Rc<Node>> {
        self.downstream.as_ref().map(|v| v.clone())
    }
}

fn main() {
    let mut node1 = Node::new(1);
    let mut node2 = Node::new(2);
    let mut node3 = Node::new(3);
    let node4 = Node::new(4);
    node3.update_downstream(Rc::new(node4));

    node1.update_downstream(Rc::new(node3));
    node2.update_downstream(node1.get_downstream().unwrap());
    println!("node1: {:?}, node2: {:?}", node1, node2);
}
```

这个是一个简单的DAG（有向无环图）的示例

在图中，我们知道会有多个节点同时指向一个节点，那我们怎么在rust中用什么表示这样的数据结构呢？

如果节点的出边定义为对另一个节点的引用，那么我们就必须保证引用的节点的生命周期不比当前节点短，也就是为了保证引用有效

但是这样做的缺点就是对于节点的生命周期，我们要自己保证，所以就很容易出现悬垂引用的情况

所以在Rust中我们用RAII的方式来处理这种多个所有者的情况

具体的，就是使用Rc，在Rc的new中，我们会把原本的node移动进去，然后用Rc来帮我们管理

可以看到，在get_downstream中，我们返回一个节点的时候会把这个节点进行clone

这其实就相当于是对Rc的增加引用技术操作

之后当引用计数为0的时候， 我们就会把原本在Rc::new中移动进去的值销毁掉

