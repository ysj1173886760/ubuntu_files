### Daily C/C++ 新版本C++中的易用性改进(2)

[参考文章](https://time.geekbang.org/column/article/176916)

自定义字面量，这个平常用的相对较少，这里就简单提一嘴

我们可以自己定义字面量，只需要我们重载`operator""`即可

这里举个例子

```cpp
length operator"" _m(long double v)
{
  return length(v, length::metre);
}

length operator"" _cm(long double v)
{
  return length(v, length::centimetre);
}
```

自定义字面量的要求就是后缀要以下划线开头，比如这里写出的两个重载，我们就可以使用类似`1.1_m`,`0.5_cm`的字面量

返回的自然是对应类型的对象了，参数就是后缀前面的具体的值

然后就是C++14支持了二进制的字面量

以0为前缀是八进制，0x是十六进制，0b则是二进制

静态断言，在C++11支持了静态的assert机制。曾经的assert是针对运行时判断的，而这里C++支持在编译期检查一个条件是否成立

用法也很简单，就是`static_assert(condition, message)`即可

然后是对于类中的特殊成员函数的修饰

编译器有时会默认提供一些成员函数，比如拷贝构造函数，移动构造函数等。但是如果这时候我们不想要编译器默认提供的，比如一个类不支持拷贝。曾经的做法是定义一个noncopyable的类，把他的拷贝构造函数和拷贝赋值函数放到private中，再让我们的类去继承。或者直接把我们的类中的相关的特殊成员函数声明为private

但是现在我们可以使用delete来修饰这个成员函数，表示删除

也可以在编译器不默认提供这个特殊成员函数的时候，使用default来让编译器提供

这里有一系列的规则用于生成这些特殊函数，但是他们都是有用意的，大家可以查阅相关资料了解

这里举个例子，如果用户没有提供一个拷贝构造函数，拷贝赋值函数，移动赋值函数，以及析构函数，那么编译器会自动提供一个移动构造函数

当我们没提供这些拷贝的行为的时候，其实就是编译器默认我们的行为是移动构造，同时还要满足我们没定义析构函数，使用的是默认的析构函数，否则的话在移动的时候会不安全。

使用方法就是在函数声明的后面加上修饰，即`function() = default`或`function() = delete`

还有两个比较常用的修饰，分别是override和final

override表示显式的重写父类的虚函数，这时候编译器会帮你检查

final则是和java类似，修饰函数表示该函数不能再被子类重写，而修饰类则表示该类不能再被继承