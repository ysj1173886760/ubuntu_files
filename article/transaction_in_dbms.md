# Recall Transaction in DBMS

事务让我们可以为上层提供一个非常强大的抽象，而不需要将具体的细节暴露给上层

事务所提供的保证，即ACID，分别代表原子性，一致性，隔离性以及持久性

有的不符合ACID的系统有时被成为BASE，即基本可用性(Basic Available)，软状态(Soft state)，最终一致性(Eventual consistency)

原子性，指的是我们可以将事务内包含的一系列操作转化为原子操作，即要么所有的操作都发生了，要么一个也没发生。注意原子性并不关乎多个操作的并发性，因为这是隔离性所保证的

一致性，在不同场景中有着不同的含义，所以请不要把他和其他地方的一致性弄混，比如最终一致性，CAP中的C表示线性化。而ACID中，一致性指的是数据库处于应用程序所期待的预期状态。比如银行中，我们希望总共的钱是不变的。如果一个事务从一个有效的状态开始，并且途中的操作都没有违反约束，那么最后的结果也就是有效的状态。本质上来说一致性是应用层的任务，因为他们需要正确的定义事务来保证一致性。**原子性，隔离性和持久性是数据库自身的属性，而一致性则更多是应用层的属性**（提出ACID的作者本人也说过C只是为了让ACID更加顺口，当时并非认为这是很重要的一件事）

隔离性，即并发的多个事务相互隔离，他们不能相互交叉。就好像是这个事务是数据库上运行的唯一一个事务一样。

持久性，即保证事务一旦提交成功，即使数据库崩溃或存在硬件故障，事务所写入的数据也不会丢失。对于单节点的数据库，持久性意味着数据已被写入非易失性存储设备，如硬盘和SSD。对于支持远程复制的数据库，持久性则意味着数据已经成功复制到多个节点。

后面的问题就主要是关于原子性和隔离性的东西了

利用日志来保证原子性和持久性，并用并发控制的手段来保证隔离性

## 弱隔离级别

### 读-提交

1.读数据库的时候，只能看到已经成功提交的数据（防止脏读）

2.写数据库的时候，只会覆盖已经成功提交的数据（防止脏写）

如果我们看到了一些未提交的数据，之后这些数据的事务中止了，那么我们就看到了一些稍后将被回滚的数据

脏写则是可能导致更新丢失，或者是由于覆盖了未提交的数据导致了不可恢复的状态

#### 实现读-提交

通过行级锁来防止脏写，修改对象的时候，要或的对象上的锁，并持有锁到事务提交

我们也可以通过相同的锁来防止脏读，但是会影响效率

大多数数据库的策略是：对于每个待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本。在事务提交之前，所有其他读操作都读取旧值; 仅当写事务提交后，才会切换到读取新值

